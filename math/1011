import sys
input = sys.stdin.readline

n = int(input())

# 그 전에 3만큼 이동했으면, 이번에는 2, 3, 4 중에 하나 이동할 수 있다!

'''
0 -> 4
1. 0 -> 1 (이동 1)
2. 1 -> 3 (이동 2)
3. 3 -> 4 (이동 1)

0 -> 5
1. 0 -> 1 (이동 1)
2. 1 -> 3 (이동 2)
3. 3 -> 4 (이동 1)
4. 4 -> 5 (이동 1)

1. 0 -> 1 (이동 1)
2. 1 -> 2 (이동 1)
3. 2 -> 4 (이동 2)
4. 4 -> 5 (이동 1)

0 -> 9 / 반: 4.5
1. 0 -> 1 (이동 1)
2. 1 -> 3 (이동 2)
3. 3 -> 6 (이동 3)
4. 6 -> 8 (이동 2)
5. 8 -> 9 (이동 1)

이동 1 / 이동 2 / 이동 3 / 이동 3 / 이동 3 / 이동 2 / 이동 1
0 -> 1 -> 3 -> 6 -> 9 -> 12 -> 14 -> 15

0 -> 15 (이거 안되네.)
1. 0 -> 1 (이동 1)
2. 1 -> 3 (이동 2)
3. 3 -> 6 (이동 3)
4. 6 -> 10 (이동 4)
5. 10 -> 13 (이동 3)
6. 13 -> 15 (이동 2)


1 -> 최대 몇 까지 수직 상승할 수 있는 지 체크 후( n(n+1)/ 2 -> 부분합 공식을 사용해서), 
최대 이동 거리부터 남은 부분을 나눈다.

즉, 최대 5까지 올라갈 수 있으면 남은 부분을 5로 나눠 몫을 보고, 나머지는 4를 기준으로 또 나눠줘서 몫을 보고.. 이런 식
(최대한 위로 올라가 되, 정체가 필요한 구간을 나눠 몫을 보는 식으로 체크하는 것이다. 최대한 위로 올라가는 것이 가장 효율적이고, 위로 올라가지는 안되 긴 정체되는 구간이
필요할 수 있으니까. 그 부분을 이렇게 표현하는 것)


'''

def func(dist):
    c = 1
    while True:
        if c*(c+1) - c > dist:
            c -= 1
            break
        c += 1
    
    return_thing = 2 * c
    dist -= c*(c+1)
    
    while dist:
        remain = dist % c
        return_thing += dist // c
        dist = remain
        c -= 1
    
    return return_thing
    

for _ in range(n):
    x, y = map(int, input().strip().split())
    ans = func(y-x)
    print(ans)  
